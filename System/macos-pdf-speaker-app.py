# -*- coding: utf-8 -*-
"""PDFSpeakerMACOS App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yfpdLQ3F70BT3rm5hDIqi4EfGLZJ7DnD
"""

import tkinter as tk
from tkinter import filedialog, messagebox
import fitz  # PyMuPDF, also known as fitz
import piper.voice
import sounddevice as sd
import numpy as np
import threading
import os
import queue
import sys # For checking macOS version if needed, though tkinter usually handles it

# --- Configuration ---
# Expects model files in a 'piper_models' subdirectory relative to the script
# Determine the base directory (directory of the script)
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
MODEL_DIR = os.path.join(BASE_DIR, "piper_models")
VOICE_MODEL_NAME = "en_US-ljspeech-high" # A good quality English voice
MODEL_PATH = os.path.join(MODEL_DIR, f"{VOICE_MODEL_NAME}.onnx")
CONFIG_PATH = os.path.join(MODEL_DIR, f"{VOICE_MODEL_NAME}.onnx.json")

# --- Global Variables ---
pdf_text_content = ""
piper_voice_instance = None
audio_playback_stream = None
tts_playback_thread = None
stop_audio_event = threading.Event()
audio_data_queue = queue.Queue(maxsize=100) # Buffer for audio chunks

# --- Core Application Logic ---

def initialize_piper_voice():
    """
    Loads the Piper TTS voice model.
    Returns True if successful, False otherwise.
    """
    global piper_voice_instance
    if piper_voice_instance:
        return True

    if not os.path.exists(MODEL_PATH) or not os.path.exists(CONFIG_PATH):
        messagebox.showerror(
            "Model Error",
            f"Piper voice model or config file not found.\n"
            f"Please ensure '{VOICE_MODEL_NAME}.onnx' and '{VOICE_MODEL_NAME}.onnx.json' "
            f"are in the '{MODEL_DIR}' subfolder."
        )
        return False
    try:
        update_status("Loading Piper voice model...")
        piper_voice_instance = piper.voice.PiperVoice.load(MODEL_PATH, config_path=CONFIG_PATH)
        if piper_voice_instance is None: # load can return None on failure
            messagebox.showerror("Model Error", "Failed to load Piper voice. The model might be incompatible or corrupt.")
            update_status("Error: Could not load Piper voice.")
            return False
        # Quick test synthesis to ensure the model is operational
        list(piper_voice_instance.synthesize_stream_raw("test"))
        update_status("Piper voice model loaded successfully.")
        return True
    except Exception as e:
        messagebox.showerror("Model Error", f"An error occurred while loading the Piper voice model: {e}")
        piper_voice_instance = None
        update_status(f"Error loading voice: {e}")
        return False

def process_pdf_file(pdf_filepath):
    """
    Extracts text content from the specified PDF file.
    Updates global pdf_text_content.
    Returns True if successful, False otherwise.
    """
    global pdf_text_content
    try:
        update_status(f"Loading PDF: {os.path.basename(pdf_filepath)}...")
        doc = fitz.open(pdf_filepath)
        extracted_text = ""
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            extracted_text += page.get_text("text") + "\n" # Add newline between pages
        doc.close()
        pdf_text_content = extracted_text
        if not pdf_text_content.strip():
            messagebox.showwarning("PDF Content", "The selected PDF appears to contain no extractable text.")
            update_status("PDF loaded, but no text found.")
            play_button.config(state=tk.DISABLED)
            return False
        update_status(f"PDF loaded: {len(pdf_text_content.split())} words. Ready to play.")
        play_button.config(state=tk.NORMAL)
        return True
    except Exception as e:
        messagebox.showerror("PDF Error", f"Failed to extract text from PDF: {e}")
        pdf_text_content = ""
        update_status(f"Error loading PDF: {e}")
        play_button.config(state=tk.DISABLED)
        return False

def audio_playback_worker():
    """
    Worker function executed in a separate thread for TTS and audio playback.
    """
    global audio_playback_stream, stop_audio_event, audio_data_queue

    if not pdf_text_content or not piper_voice_instance:
        update_status("Error: No text to play or voice model not loaded.")
        _reset_playback_controls()
        return

    stop_audio_event.clear()
    update_status("Synthesizing audio...")

    try:
        sample_rate = piper_voice_instance.sample_rate
        num_channels = piper_voice_instance.num_channels
        sample_width_bytes = piper_voice_instance.sample_width

        dtype_map = {1: 'int8', 2: 'int16', 4: 'int32'}
        if sample_width_bytes not in dtype_map:
            raise ValueError(f"Unsupported audio sample width: {sample_width_bytes} bytes.")
        audio_dtype = dtype_map[sample_width_bytes]

        # Audio callback for sounddevice
        def sd_callback(outdata, frames, time, status_flags):
            if status_flags:
                print(f"Sounddevice status: {status_flags}", file=sys.stderr) # Log to stderr

            assert frames == outdata.shape[0]

            data_to_play = bytearray()
            while len(data_to_play) < frames * num_channels * sample_width_bytes:
                if stop_audio_event.is_set() and audio_data_queue.empty(): # Stop if flagged and queue empty
                    break
                try:
                    chunk = audio_data_queue.get_nowait()
                    if chunk is None: # Sentinel for end of synthesis
                        audio_data_queue.task_done()
                        break
                    data_to_play.extend(chunk)
                    audio_data_queue.task_done()
                except queue.Empty:
                    # Queue is empty, but synthesis might not be done yet
                    if not stop_audio_event.is_set(): # Only break if not stopping
                        break # Wait for more data

            if not data_to_play and (stop_audio_event.is_set() or (audio_data_queue.empty() and audio_data_queue._unfinished_tasks == 0)):
                # No data and (stopping or synthesis truly finished)
                outdata.fill(0) # Fill with silence
                raise sd.CallbackStop # Signal end of playback

            num_samples_to_play = len(data_to_play) // (num_channels * sample_width_bytes)
            if num_samples_to_play > 0:
                audio_array = np.frombuffer(data_to_play, dtype=audio_dtype).reshape(-1, num_channels)
                actual_frames_from_buffer = min(frames, num_samples_to_play)

                outdata[:actual_frames_from_buffer] = audio_array[:actual_frames_from_buffer]

                # If fewer frames were played than requested, fill rest with silence
                if actual_frames_from_buffer < frames:
                    outdata[actual_frames_from_buffer:] = 0
            else: # No data to play this round
                outdata.fill(0)


        # Start audio stream
        with sd.OutputStream(
            samplerate=sample_rate,
            channels=num_channels,
            dtype=audio_dtype,
            callback=sd_callback,
            blocksize=1024 # Adjust blocksize for latency/performance if needed
        ) as stream:
            audio_playback_stream = stream # Store for external stop
            update_status("Playing audio...")

            # Synthesize and queue audio data
            synthesis_generator = piper_voice_instance.synthesize_stream_raw(pdf_text_content)
            for audio_chunk in synthesis_generator:
                if stop_audio_event.is_set():
                    update_status("Playback stopped during synthesis.")
                    break
                audio_data_queue.put(audio_chunk)

            audio_data_queue.put(None) # Sentinel: end of synthesis
            audio_data_queue.join() # Wait for all queued items to be processed by callback

            # Keep stream alive while playing, or until stop_event is set
            while stream.active and not stop_audio_event.is_set():
                sd.sleep(50) # Check periodically

    except Exception as e:
        messagebox.showerror("Playback Error", f"An error occurred during audio playback: {e}")
        update_status(f"Error during playback: {e}")
    finally:
        # Ensure queue is cleared for next run
        while not audio_data_queue.empty():
            try:
                audio_data_queue.get_nowait()
                audio_data_queue.task_done()
            except queue.Empty:
                break

        if not stop_audio_event.is_set() and "Error" not in status_label.cget("text"):
             update_status("Playback finished.")

        _reset_playback_controls()
        audio_playback_stream = None

def _reset_playback_controls():
    """Resets GUI buttons to their default states after playback."""
    play_button.config(state=tk.NORMAL if pdf_text_content else tk.DISABLED)
    stop_button.config(state=tk.DISABLED)

# --- GUI Event Handlers ---

def on_load_pdf_button_click():
    """Handles the 'Load PDF' button click event."""
    filepath = filedialog.askopenfilename(
        title="Select PDF File",
        filetypes=(("PDF Files", "*.pdf"), ("All Files", "*.*"))
    )
    if filepath:
        if not piper_voice_instance: # Ensure voice is loaded
            if not initialize_piper_voice():
                play_button.config(state=tk.DISABLED) # Keep play disabled if voice fails
                return
        process_pdf_file(filepath)
    else:
        update_status("PDF loading cancelled.")

def on_play_button_click():
    """Handles the 'Play' button click event."""
    global tts_playback_thread
    if not pdf_text_content:
        messagebox.showwarning("No Content", "Please load a PDF file first.")
        return
    if not piper_voice_instance:
        messagebox.showerror("Voice Error", "Piper voice model is not loaded. Please restart or check model files.")
        if not initialize_piper_voice(): # Try to load again
             return

    if tts_playback_thread and tts_playback_thread.is_alive():
        messagebox.showwarning("Busy", "Audio playback is already in progress.")
        return

    play_button.config(state=tk.DISABLED)
    stop_button.config(state=tk.NORMAL)

    stop_audio_event.clear() # Ensure event is clear before starting
    # Clear queue before starting new playback
    while not audio_data_queue.empty():
        try:
            audio_data_queue.get_nowait()
            audio_data_queue.task_done()
        except queue.Empty:
            break

    tts_playback_thread = threading.Thread(target=audio_playback_worker, daemon=True)
    tts_playback_thread.start()

def on_stop_button_click():
    """Handles the 'Stop' button click event."""
    global audio_playback_stream, tts_playback_thread
    update_status("Stopping playback...")
    stop_audio_event.set() # Signal the worker thread and callback to stop

    # The callback will see the event and raise sd.CallbackStop
    # The worker thread will see the event and break loops

    # It's good practice to wait for the thread to finish, but with a timeout
    if tts_playback_thread and tts_playback_thread.is_alive():
        tts_playback_thread.join(timeout=1.0) # Wait for 1 sec
        if tts_playback_thread.is_alive():
            print("Warning: Playback thread did not terminate cleanly after 1s.", file=sys.stderr)
            # Forcibly stopping the sounddevice stream if join times out and stream is still active
            if audio_playback_stream and audio_playback_stream.active:
                try:
                    audio_playback_stream.stop()
                    audio_playback_stream.close()
                except Exception as e:
                    print(f"Error force stopping stream: {e}", file=sys.stderr)

    # Queue should be cleared by the worker or here if thread terminated abruptly
    while not audio_data_queue.empty():
        try:
            audio_data_queue.get_nowait()
            audio_data_queue.task_done()
        except queue.Empty:
            break

    update_status("Playback stopped.")
    _reset_playback_controls()
    # stop_audio_event.clear() # Reset for next potential playback, already done in play

def on_application_close():
    """Handles the window close event."""
    on_stop_button_click() # Attempt to stop any ongoing playback gracefully
    if messagebox.askokcancel("Quit", "Are you sure you want to quit PDFSpeakerMACOS?"):
        root.destroy()

def update_status(message):
    """Updates the status bar text."""
    status_label.config(text=message)
    root.update_idletasks() # Ensure GUI updates immediately

# --- GUI Setup ---
root = tk.Tk()
root.title("PDFSpeakerMACOS ðŸ”ŠðŸ“„")
root.geometry("550x150") # Adjusted size for better layout
root.minsize(400, 120)

# Main application frame
app_frame = tk.Frame(root, padx=15, pady=15)
app_frame.pack(expand=True, fill=tk.BOTH)

# Controls frame
controls_frame = tk.Frame(app_frame)
controls_frame.pack(pady=(0, 10)) # Add some padding below controls

load_button = tk.Button(controls_frame, text="1. Load PDF", command=on_load_pdf_button_click, width=15, height=2)
load_button.pack(side=tk.LEFT, padx=5)

play_button = tk.Button(controls_frame, text="2. Play Audio", command=on_play_button_click, state=tk.DISABLED, width=15, height=2)
play_button.pack(side=tk.LEFT, padx=5)

stop_button = tk.Button(controls_frame, text="Stop Audio", command=on_stop_button_click, state=tk.DISABLED, width=15, height=2)
stop_button.pack(side=tk.LEFT, padx=5)

# Status bar
status_label = tk.Label(app_frame, text="Welcome! Load a PDF to begin.", relief=tk.SUNKEN, bd=1, anchor=tk.W, padx=5)
status_label.pack(side=tk.BOTTOM, fill=tk.X, ipady=5)

# --- Application Initialization ---
if __name__ == "__main__":
    # Attempt to initialize Piper voice on startup in a non-blocking way (optional)
    # For simplicity here, it will be loaded on first PDF load attempt if not already.
    # You could use a thread for initial load if it's slow:
    # initial_load_thread = threading.Thread(target=initialize_piper_voice, daemon=True)
    # initial_load_thread.start()
    # However, it's often better to ensure it's loaded before enabling play.

    # Set the application close protocol
    root.protocol("WM_DELETE_WINDOW", on_application_close)

    # Start the Tkinter event loop
    root.mainloop()