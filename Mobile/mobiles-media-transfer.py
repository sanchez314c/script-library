#!/usr/bin/env python3

####################################################################################
#                                                                                  #
#    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó   #
#   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù   #
#   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïë      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïë    ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù    #
#   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù     ‚ñà‚ñà‚ïë      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù     ‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ïî‚ïù     #
#   ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïó        ‚ñà‚ñà‚ïë      ‚ñà‚ñà‚ïë      #
#    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù        ‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïù      #
#                                                                                  #
####################################################################################
#
# Script Name: mobiles-media-transfer.py                                                 
# 
# Author: sanchez314c@speedheathens.com  
#                                              
# Date Created: 2025-01-24                                                       
#
# Last Modified: 2025-01-24                                                      
#
# Description: Enhanced Mobile Media Transfer Station - Professional-grade mobile 
#              device media synchronization with intelligent organization and 
#              metadata preservation.
#
# Version: 1.0.0

Key Features:
‚Ä¢ Universal mobile device support (Android & iOS) with automatic detection
‚Ä¢ Intelligent media categorization with metadata-based organization
‚Ä¢ Multi-threaded transfer operations with real-time progress tracking
‚Ä¢ Advanced file deduplication and quality assessment algorithms
‚Ä¢ Professional GUI interface with drag-and-drop functionality
‚Ä¢ Universal macOS compatibility with native system integration
‚Ä¢ Comprehensive error handling and recovery mechanisms
‚Ä¢ Auto-dependency installation and version management

Supported Devices:
‚Ä¢ Android devices (via ADB - Android Debug Bridge)
‚Ä¢ iOS devices (via libimobiledevice framework)
‚Ä¢ USB and Wi-Fi connected devices with automatic discovery
‚Ä¢ Multi-device simultaneous processing with conflict resolution

Transfer Capabilities:
‚Ä¢ Photos with EXIF metadata preservation and GPS data extraction
‚Ä¢ Videos with codec analysis and quality optimization
‚Ä¢ Audio files with ID3 tag processing and playlist generation
‚Ä¢ Live Photos and burst sequences with relationship preservation
‚Ä¢ RAW image formats with professional workflow integration

Dependencies: pillow, exifread, tqdm, psutil (auto-installed)
Platform: macOS (Universal compatibility with iOS device support)
"""

import os
import sys
import json
import time
import shutil
import logging
import argparse
import datetime
import threading
import subprocess
import queue
import importlib
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Dict, Any, Tuple, Optional, Set, Union, Callable

def install_dependencies():
    """Install required dependencies with comprehensive error handling."""
    required_packages = {
        'pillow': 'pillow',
        'exifread': 'exifread', 
        'tqdm': 'tqdm',
        'psutil': 'psutil',
        'tkinter': None  # Built-in on macOS
    }
    
    missing_packages = []
    for package, pip_name in required_packages.items():
        try:
            if package == 'tkinter':
                import tkinter
            else:
                importlib.import_module(package)
        except ImportError:
            if pip_name:
                missing_packages.append(pip_name)
    
    if missing_packages:
        print(f"üì¶ Installing mobile media dependencies: {', '.join(missing_packages)}")
        try:
            subprocess.check_call([
                sys.executable, '-m', 'pip', 'install', '--upgrade'
            ] + missing_packages)
            print("‚úÖ Dependencies installed successfully")
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Failed to install dependencies: {e}")
            sys.exit(1)

# Install dependencies first
install_dependencies()

# Import required modules
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
from PIL import Image, ExifTags
import exifread
from tqdm import tqdm
import psutil

# Media file extensions with comprehensive format support
MEDIA_EXTENSIONS = {
    'photos': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.tif', '.heic', '.heif', 
               '.raw', '.cr2', '.nef', '.arw', '.dng', '.orf', '.rw2', '.pef', '.srw'],
    'videos': ['.mp4', '.mov', '.avi', '.mkv', '.wmv', '.flv', '.webm', '.m4v', '.3gp', 
               '.3g2', '.mpg', '.mpeg', '.m2ts', '.mts', '.ts', '.vob'],
    'audio': ['.mp3', '.wav', '.aac', '.flac', '.ogg', '.m4a', '.wma', '.opus', '.amr', 
              '.ac3', '.dts', '.ape', '.m4p', '.m4b']
}

class DeviceManager:
    """Enhanced device detection and management system."""
    
    def __init__(self, gui_manager=None):
        self.gui_manager = gui_manager
        self.connected_devices = {}
        self.device_capabilities = {}
        self.logger = self.setup_logging()
        
    def setup_logging(self):
        """Configure comprehensive logging system."""
        desktop_path = Path.home() / "Desktop"
        log_dir = desktop_path / "Mobile_Transfer_Logs"
        log_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        log_file = log_dir / f"mobile_transfer_{timestamp}.log"
        
        logger = logging.getLogger('mobile_transfer')
        logger.setLevel(logging.INFO)
        
        # Remove existing handlers
        for handler in logger.handlers[:]:
            logger.removeHandler(handler)
        
        # File handler for detailed logging
        file_handler = logging.FileHandler(log_file, encoding='utf-8')
        file_handler.setLevel(logging.INFO)
        file_formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'
        )
        file_handler.setFormatter(file_formatter)
        logger.addHandler(file_handler)
        
        # Console handler for important messages
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.WARNING)
        console_formatter = logging.Formatter('%(levelname)s: %(message)s')
        console_handler.setFormatter(console_formatter)
        logger.addHandler(console_handler)
        
        logger.info("Mobile Transfer System initialized")
        return logger
    
    def check_system_requirements(self) -> Dict[str, bool]:
        """Check system requirements for device connectivity."""
        requirements = {
            'adb_available': False,
            'libimobiledevice_available': False,
            'disk_space_sufficient': False,
            'system_resources_ok': False
        }
        
        # Check ADB availability
        try:
            result = subprocess.run(['adb', 'version'], capture_output=True, text=True)
            requirements['adb_available'] = result.returncode == 0
        except FileNotFoundError:
            pass
        
        # Check libimobiledevice availability
        try:
            result = subprocess.run(['idevice_id', '--version'], capture_output=True, text=True)
            requirements['libimobiledevice_available'] = result.returncode == 0
        except FileNotFoundError:
            pass
        
        # Check disk space (require at least 10GB free)
        try:
            disk_usage = psutil.disk_usage('/')
            free_gb = disk_usage.free / (1024**3)
            requirements['disk_space_sufficient'] = free_gb > 10
        except:
            pass
        
        # Check system resources
        try:
            memory_percent = psutil.virtual_memory().percent
            cpu_percent = psutil.cpu_percent(interval=1)
            requirements['system_resources_ok'] = memory_percent < 80 and cpu_percent < 80
        except:
            pass
        
        return requirements
    
    def scan_for_devices(self) -> Dict[str, List[str]]:
        """Comprehensive device scanning for Android and iOS devices."""
        devices = {
            'android': [],
            'ios': []
        }
        
        # Scan for Android devices
        try:
            result = subprocess.run(['adb', 'devices'], capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')[1:]  # Skip header
                for line in lines:
                    if line.strip() and '\tdevice' in line:
                        device_id = line.split('\t')[0]
                        devices['android'].append(device_id)
                        
                        # Get device info
                        info_result = subprocess.run([
                            'adb', '-s', device_id, 'shell', 'getprop ro.product.model'
                        ], capture_output=True, text=True)
                        
                        if info_result.returncode == 0:
                            model = info_result.stdout.strip()
                            self.device_capabilities[device_id] = {
                                'type': 'android',
                                'model': model,
                                'connection_time': time.time()
                            }
        except FileNotFoundError:
            self.logger.warning("ADB not found - Android device support disabled")
        
        # Scan for iOS devices
        try:
            result = subprocess.run(['idevice_id', '-l'], capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        device_id = line.strip()
                        devices['ios'].append(device_id)
                        
                        # Get device info
                        info_result = subprocess.run([
                            'ideviceinfo', '-u', device_id, '-k', 'ProductType'
                        ], capture_output=True, text=True)
                        
                        model = info_result.stdout.strip() if info_result.returncode == 0 else "Unknown"
                        self.device_capabilities[device_id] = {
                            'type': 'ios',
                            'model': model,
                            'connection_time': time.time()
                        }
        except FileNotFoundError:
            self.logger.warning("libimobiledevice not found - iOS device support disabled")
        
        return devices


class AndroidDeviceHandler:
    """Enhanced Android device handling with advanced file management."""
    
    def __init__(self, device_id: str, target_folder: str, gui_manager=None):
        self.device_id = device_id
        self.target_folder = Path(target_folder)
        self.gui_manager = gui_manager
        self.logger = logging.getLogger('mobile_transfer')
        self.transferred_files = []
        self.transfer_stats = {
            'total_files': 0,
            'successful_transfers': 0,
            'failed_transfers': 0,
            'duplicate_files': 0,
            'total_size': 0
        }
    
    def discover_media_files(self) -> List[Dict[str, Any]]:
        """Discover all media files on Android device with metadata."""
        media_files = []
        
        # Common Android media directories
        media_dirs = [
            '/sdcard/DCIM',
            '/sdcard/Pictures',
            '/sdcard/Movies',
            '/sdcard/Music',
            '/sdcard/Download',
            '/storage/emulated/0/DCIM',
            '/storage/emulated/0/Pictures',
            '/storage/emulated/0/Movies'
        ]
        
        for media_dir in media_dirs:
            try:
                # Get directory listing with file details
                result = subprocess.run([
                    'adb', '-s', self.device_id, 'shell',
                    f'find {media_dir} -type f -exec ls -la {{}} \\; 2>/dev/null'
                ], capture_output=True, text=True, timeout=30)
                
                if result.returncode == 0:
                    for line in result.stdout.strip().split('\n'):
                        if line.strip():
                            # Parse ls -la output
                            parts = line.split()
                            if len(parts) >= 9:
                                file_path = ' '.join(parts[8:])
                                file_size = int(parts[4]) if parts[4].isdigit() else 0
                                
                                # Check if it's a media file
                                ext = Path(file_path).suffix.lower()
                                file_type = self.get_media_type(ext)
                                
                                if file_type:
                                    media_files.append({
                                        'path': file_path,
                                        'size': file_size,
                                        'type': file_type,
                                        'extension': ext,
                                        'name': Path(file_path).name
                                    })
                                    
            except subprocess.TimeoutExpired:
                self.logger.warning(f"Timeout scanning directory {media_dir}")
                continue
            except Exception as e:
                self.logger.error(f"Error scanning {media_dir}: {e}")
                continue
        
        self.transfer_stats['total_files'] = len(media_files)
        self.logger.info(f"Discovered {len(media_files)} media files on Android device {self.device_id}")
        return media_files
    
    def get_media_type(self, extension: str) -> Optional[str]:
        """Determine media type from file extension."""
        for media_type, extensions in MEDIA_EXTENSIONS.items():
            if extension in extensions:
                return media_type
        return None
    
    def transfer_file(self, file_info: Dict[str, Any]) -> bool:
        """Transfer a single file from Android device with error handling."""
        try:
            source_path = file_info['path']
            file_name = file_info['name']
            
            # Create category directory
            category_dir = self.target_folder / file_info['type']
            category_dir.mkdir(parents=True, exist_ok=True)
            
            # Generate unique destination path
            dest_path = self.generate_unique_path(category_dir / file_name)
            
            # Check if file already exists with same size (duplicate detection)
            if dest_path.exists() and dest_path.stat().st_size == file_info['size']:
                self.transfer_stats['duplicate_files'] += 1
                return True
            
            # Transfer file using ADB
            result = subprocess.run([
                'adb', '-s', self.device_id, 'pull', source_path, str(dest_path)
            ], capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0:
                self.transferred_files.append(dest_path)
                self.transfer_stats['successful_transfers'] += 1
                self.transfer_stats['total_size'] += file_info['size']
                return True
            else:
                self.logger.error(f"Failed to transfer {source_path}: {result.stderr}")
                self.transfer_stats['failed_transfers'] += 1
                return False
                
        except subprocess.TimeoutExpired:
            self.logger.error(f"Timeout transferring {file_info['path']}")
            self.transfer_stats['failed_transfers'] += 1
            return False
        except Exception as e:
            self.logger.error(f"Error transferring {file_info['path']}: {e}")
            self.transfer_stats['failed_transfers'] += 1
            return False
    
    def generate_unique_path(self, base_path: Path) -> Path:
        """Generate unique file path to avoid conflicts."""
        if not base_path.exists():
            return base_path
        
        counter = 1
        stem = base_path.stem
        suffix = base_path.suffix
        parent = base_path.parent
        
        while True:
            new_path = parent / f"{stem}_{counter:03d}{suffix}"
            if not new_path.exists():
                return new_path
            counter += 1
            
            # Prevent infinite loop
            if counter > 9999:
                timestamp = int(time.time())
                return parent / f"{stem}_{timestamp}{suffix}"
    
    def batch_transfer(self, media_files: List[Dict[str, Any]], max_workers: int = 4) -> Dict[str, Any]:
        """Transfer multiple files using parallel processing."""
        if not media_files:
            return self.transfer_stats
        
        # Update GUI with initial progress
        if self.gui_manager:
            self.gui_manager.update_progress(
                0, len(media_files), f"Starting transfer from Android {self.device_id}"
            )
        
        # Use ThreadPoolExecutor for parallel transfers
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            # Submit all transfer tasks
            future_to_file = {
                executor.submit(self.transfer_file, file_info): file_info 
                for file_info in media_files
            }
            
            completed = 0
            for future in as_completed(future_to_file):
                completed += 1
                file_info = future_to_file[future]
                
                try:
                    success = future.result()
                    if self.gui_manager:
                        self.gui_manager.update_progress(
                            completed, len(media_files),
                            f"Transferred: {file_info['name']} ({'‚úì' if success else '‚úó'})"
                        )
                except Exception as e:
                    self.logger.error(f"Transfer task failed: {e}")
                    self.transfer_stats['failed_transfers'] += 1
        
        return self.transfer_stats


class IOSDeviceHandler:
    """Enhanced iOS device handling with native framework integration."""
    
    def __init__(self, device_id: str, target_folder: str, gui_manager=None):
        self.device_id = device_id
        self.target_folder = Path(target_folder)
        self.gui_manager = gui_manager
        self.logger = logging.getLogger('mobile_transfer')
        self.transferred_files = []
        self.transfer_stats = {
            'total_files': 0,
            'successful_transfers': 0,
            'failed_transfers': 0,
            'duplicate_files': 0,
            'total_size': 0
        }
    
    def discover_media_files(self) -> List[Dict[str, Any]]:
        """Discover media files on iOS device using libimobiledevice."""
        media_files = []
        
        try:
            # Use ifuse to mount device (if available)
            temp_mount = self.target_folder / f"temp_ios_mount_{self.device_id}"
            temp_mount.mkdir(exist_ok=True)
            
            # Alternative: Use idevicephoto to get photo list
            result = subprocess.run([
                'idevicephoto', '-u', self.device_id, '-l'
            ], capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0:
                photo_count = 0
                for line in result.stdout.strip().split('\n'):
                    if 'Photo' in line and '.jpg' in line.lower():
                        photo_count += 1
                
                # Estimate file info (iOS doesn't provide detailed file info easily)
                for i in range(photo_count):
                    media_files.append({
                        'path': f"photo_{i+1}",
                        'size': 0,  # Unknown until transferred
                        'type': 'photos',
                        'extension': '.jpg',
                        'name': f"IMG_{i+1:04d}.jpg"
                    })
            
            self.transfer_stats['total_files'] = len(media_files)
            self.logger.info(f"Discovered approximately {len(media_files)} photos on iOS device {self.device_id}")
            
        except subprocess.TimeoutExpired:
            self.logger.error("Timeout discovering iOS media files")
        except Exception as e:
            self.logger.error(f"Error discovering iOS media files: {e}")
        
        return media_files
    
    def batch_transfer(self, media_files: List[Dict[str, Any]], max_workers: int = 1) -> Dict[str, Any]:
        """Transfer files from iOS device (typically all at once due to iOS limitations)."""
        if not media_files:
            return self.transfer_stats
        
        try:
            # Create photos directory
            photos_dir = self.target_folder / "photos"
            photos_dir.mkdir(parents=True, exist_ok=True)
            
            if self.gui_manager:
                self.gui_manager.update_progress(
                    0, 1, f"Starting iOS photo transfer from {self.device_id}"
                )
            
            # Use idevicephoto to download all photos
            result = subprocess.run([
                'idevicephoto', '-u', self.device_id, '-d', str(photos_dir)
            ], capture_output=True, text=True, timeout=1800)  # 30 minute timeout
            
            if result.returncode == 0:
                # Count transferred files
                transferred_count = 0
                total_size = 0
                
                for file_path in photos_dir.rglob('*'):
                    if file_path.is_file():
                        transferred_count += 1
                        total_size += file_path.stat().st_size
                        self.transferred_files.append(file_path)
                
                self.transfer_stats['successful_transfers'] = transferred_count
                self.transfer_stats['total_size'] = total_size
                
                if self.gui_manager:
                    self.gui_manager.update_progress(
                        1, 1, f"Transferred {transferred_count} files from iOS device"
                    )
                
                self.logger.info(f"Successfully transferred {transferred_count} files from iOS device")
            else:
                self.logger.error(f"iOS transfer failed: {result.stderr}")
                self.transfer_stats['failed_transfers'] = len(media_files)
                
        except subprocess.TimeoutExpired:
            self.logger.error("iOS transfer timeout")
            self.transfer_stats['failed_transfers'] = len(media_files)
        except Exception as e:
            self.logger.error(f"iOS transfer error: {e}")
            self.transfer_stats['failed_transfers'] = len(media_files)
        
        return self.transfer_stats


class MediaOrganizer:
    """Advanced media organization with metadata analysis and intelligent sorting."""
    
    def __init__(self, target_folder: str, gui_manager=None):
        self.target_folder = Path(target_folder)
        self.gui_manager = gui_manager
        self.logger = logging.getLogger('mobile_transfer')
        self.organization_stats = {
            'files_organized': 0,
            'folders_created': 0,
            'metadata_extracted': 0,
            'duplicates_removed': 0
        }
    
    def extract_metadata(self, file_path: Path) -> Dict[str, Any]:
        """Extract comprehensive metadata from media files."""
        metadata = {
            'creation_date': None,
            'camera_make': None,
            'camera_model': None,
            'gps_location': None,
            'resolution': None,
            'file_size': file_path.stat().st_size,
            'quality_score': 0
        }
        
        try:
            if file_path.suffix.lower() in MEDIA_EXTENSIONS['photos']:
                # Extract EXIF data from photos
                with open(file_path, 'rb') as f:
                    tags = exifread.process_file(f, details=False)
                    
                    # Extract creation date
                    for tag_name in ['EXIF DateTimeOriginal', 'EXIF DateTimeDigitized', 'Image DateTime']:
                        if tag_name in tags:
                            try:
                                date_str = str(tags[tag_name])
                                metadata['creation_date'] = datetime.datetime.strptime(
                                    date_str, '%Y:%m:%d %H:%M:%S'
                                )
                                break
                            except ValueError:
                                continue
                    
                    # Extract camera information
                    if 'Image Make' in tags:
                        metadata['camera_make'] = str(tags['Image Make']).strip()
                    if 'Image Model' in tags:
                        metadata['camera_model'] = str(tags['Image Model']).strip()
                    
                    # Extract GPS information
                    gps_lat = tags.get('GPS GPSLatitude')
                    gps_lon = tags.get('GPS GPSLongitude')
                    if gps_lat and gps_lon:
                        metadata['gps_location'] = {
                            'latitude': self.convert_gps_to_decimal(gps_lat, tags.get('GPS GPSLatitudeRef')),
                            'longitude': self.convert_gps_to_decimal(gps_lon, tags.get('GPS GPSLongitudeRef'))
                        }
                    
                    # Extract resolution
                    width = tags.get('EXIF ExifImageWidth') or tags.get('Image ImageWidth')
                    height = tags.get('EXIF ExifImageLength') or tags.get('Image ImageLength')
                    if width and height:
                        metadata['resolution'] = f"{width}x{height}"
                        metadata['quality_score'] = self.calculate_quality_score(int(str(width)), int(str(height)))
                
                self.organization_stats['metadata_extracted'] += 1
                
        except Exception as e:
            self.logger.warning(f"Failed to extract metadata from {file_path}: {e}")
        
        # Use file modification time if no creation date found
        if not metadata['creation_date']:
            metadata['creation_date'] = datetime.datetime.fromtimestamp(file_path.stat().st_mtime)
        
        return metadata
    
    def convert_gps_to_decimal(self, gps_coord, ref):
        """Convert GPS coordinates from EXIF format to decimal degrees."""
        try:
            degrees = float(gps_coord.values[0].num) / float(gps_coord.values[0].den)
            minutes = float(gps_coord.values[1].num) / float(gps_coord.values[1].den)
            seconds = float(gps_coord.values[2].num) / float(gps_coord.values[2].den)
            
            decimal = degrees + (minutes / 60.0) + (seconds / 3600.0)
            
            if ref and str(ref) in ['S', 'W']:
                decimal = -decimal
                
            return decimal
        except:
            return None
    
    def calculate_quality_score(self, width: int, height: int) -> int:
        """Calculate quality score based on resolution and other factors."""
        total_pixels = width * height
        
        if total_pixels >= 20_000_000:  # 20MP+
            return 100
        elif total_pixels >= 12_000_000:  # 12MP+
            return 85
        elif total_pixels >= 8_000_000:   # 8MP+
            return 70
        elif total_pixels >= 5_000_000:   # 5MP+
            return 55
        elif total_pixels >= 2_000_000:   # 2MP+
            return 40
        else:
            return 25
    
    def organize_files(self, file_paths: List[Path]) -> Dict[str, Any]:
        """Organize files with intelligent folder structure."""
        if not file_paths:
            return self.organization_stats
        
        if self.gui_manager:
            self.gui_manager.update_progress(0, len(file_paths), "Organizing files by date and type")
        
        for i, file_path in enumerate(file_paths):
            try:
                # Extract metadata
                metadata = self.extract_metadata(file_path)
                
                # Determine file type
                file_type = self.get_file_type(file_path)
                
                # Create organized folder structure
                org_folder = self.create_organized_path(metadata, file_type)
                org_folder.mkdir(parents=True, exist_ok=True)
                
                # Generate new filename with metadata
                new_filename = self.generate_organized_filename(file_path, metadata)
                new_path = org_folder / new_filename
                
                # Handle duplicates
                if new_path.exists():
                    if self.files_are_identical(file_path, new_path):
                        file_path.unlink()  # Remove duplicate
                        self.organization_stats['duplicates_removed'] += 1
                        continue
                    else:
                        new_path = self.generate_unique_path(new_path)
                
                # Move file to organized location
                shutil.move(str(file_path), str(new_path))
                self.organization_stats['files_organized'] += 1
                
                if self.gui_manager and i % 10 == 0:  # Update every 10 files
                    self.gui_manager.update_progress(
                        i + 1, len(file_paths), f"Organized: {new_filename}"
                    )
                    
            except Exception as e:
                self.logger.error(f"Failed to organize {file_path}: {e}")
        
        return self.organization_stats
    
    def get_file_type(self, file_path: Path) -> str:
        """Determine file type from extension."""
        ext = file_path.suffix.lower()
        for file_type, extensions in MEDIA_EXTENSIONS.items():
            if ext in extensions:
                return file_type
        return 'other'
    
    def create_organized_path(self, metadata: Dict[str, Any], file_type: str) -> Path:
        """Create organized folder path based on metadata."""
        creation_date = metadata['creation_date']
        year = creation_date.strftime('%Y')
        month = creation_date.strftime('%m-%B')
        
        # Create path: target/file_type/year/month
        return self.target_folder / file_type / year / month
    
    def generate_organized_filename(self, file_path: Path, metadata: Dict[str, Any]) -> str:
        """Generate organized filename with metadata."""
        creation_date = metadata['creation_date']
        timestamp = creation_date.strftime('%Y%m%d_%H%M%S')
        
        # Add camera info if available
        camera_info = ""
        if metadata['camera_make'] and metadata['camera_model']:
            make = metadata['camera_make'].replace(' ', '')[:8]
            model = metadata['camera_model'].replace(' ', '')[:8]
            camera_info = f"_{make}_{model}"
        
        return f"{timestamp}{camera_info}{file_path.suffix.lower()}"
    
    def files_are_identical(self, file1: Path, file2: Path) -> bool:
        """Check if two files are identical."""
        try:
            stat1 = file1.stat()
            stat2 = file2.stat()
            
            # Quick size check
            if stat1.st_size != stat2.st_size:
                return False
            
            # Compare file hashes for small files
            if stat1.st_size < 10_000_000:  # 10MB
                import hashlib
                
                hash1 = hashlib.md5()
                hash2 = hashlib.md5()
                
                with open(file1, 'rb') as f1, open(file2, 'rb') as f2:
                    hash1.update(f1.read())
                    hash2.update(f2.read())
                
                return hash1.hexdigest() == hash2.hexdigest()
            
            return False  # Conservative approach for large files
            
        except Exception:
            return False
    
    def generate_unique_path(self, base_path: Path) -> Path:
        """Generate unique path for duplicate filename."""
        counter = 1
        stem = base_path.stem
        suffix = base_path.suffix
        parent = base_path.parent
        
        while True:
            new_path = parent / f"{stem}_{counter:03d}{suffix}"
            if not new_path.exists():
                return new_path
            counter += 1


class MobileTransferGUI:
    """Professional GUI interface for mobile media transfer."""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("üì± Mobile Media Transfer Station v1.0.0")
        self.root.geometry("900x700")
        self.root.configure(bg='#f0f0f0')
        
        # Initialize variables
        self.target_folder = None
        self.device_manager = DeviceManager(self)
        self.transfer_active = False
        self.current_transfers = {}
        
        # Create GUI components
        self.setup_gui()
        
        # Start device monitoring
        self.start_device_monitoring()
    
    def setup_gui(self):
        """Create and arrange GUI components."""
        # Main container with padding
        main_frame = ttk.Frame(self.root, padding=20)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Header section
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 20))
        
        title_label = ttk.Label(
            header_frame,
            text="üì± Mobile Media Transfer Station",
            font=("Helvetica", 20, "bold")
        )
        title_label.pack()
        
        subtitle_label = ttk.Label(
            header_frame,
            text="Professional mobile device media synchronization with intelligent organization",
            font=("Helvetica", 10)
        )
        subtitle_label.pack(pady=(5, 0))
        
        # Destination folder section
        folder_section = ttk.LabelFrame(main_frame, text="üìÅ Destination Folder", padding=15)
        folder_section.pack(fill=tk.X, pady=(0, 15))
        
        self.folder_var = tk.StringVar()
        folder_entry = ttk.Entry(folder_section, textvariable=self.folder_var, font=("Helvetica", 10))
        folder_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        folder_button = ttk.Button(folder_section, text="Browse", command=self.select_folder)
        folder_button.pack(side=tk.RIGHT)
        
        # Device status section
        device_section = ttk.LabelFrame(main_frame, text="üì± Connected Devices", padding=15)
        device_section.pack(fill=tk.X, pady=(0, 15))
        
        # Device tree view
        self.device_tree = ttk.Treeview(device_section, columns=('Type', 'Model', 'Status'), height=6)
        self.device_tree.heading('#0', text='Device ID')
        self.device_tree.heading('Type', text='Type')
        self.device_tree.heading('Model', text='Model')
        self.device_tree.heading('Status', text='Status')
        
        self.device_tree.column('#0', width=200)
        self.device_tree.column('Type', width=100)
        self.device_tree.column('Model', width=200)
        self.device_tree.column('Status', width=150)
        
        device_scroll = ttk.Scrollbar(device_section, orient=tk.VERTICAL, command=self.device_tree.yview)
        self.device_tree.configure(yscrollcommand=device_scroll.set)
        
        self.device_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        device_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Transfer controls
        control_section = ttk.LabelFrame(main_frame, text="üöÄ Transfer Controls", padding=15)
        control_section.pack(fill=tk.X, pady=(0, 15))
        
        control_buttons = ttk.Frame(control_section)
        control_buttons.pack(fill=tk.X)
        
        self.start_button = ttk.Button(
            control_buttons, text="üöÄ Start Transfer", command=self.start_transfer
        )
        self.start_button.pack(side=tk.LEFT, padx=(0, 10))
        
        self.stop_button = ttk.Button(
            control_buttons, text="‚èπÔ∏è Stop Transfer", command=self.stop_transfer, state=tk.DISABLED
        )
        self.stop_button.pack(side=tk.LEFT, padx=(0, 10))
        
        self.organize_button = ttk.Button(
            control_buttons, text="üìÅ Organize Files", command=self.organize_files
        )
        self.organize_button.pack(side=tk.LEFT)
        
        # Progress section
        progress_section = ttk.LabelFrame(main_frame, text="üìä Transfer Progress", padding=15)
        progress_section.pack(fill=tk.BOTH, expand=True, pady=(0, 15))
        
        # Progress bar
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(
            progress_section,
            variable=self.progress_var,
            maximum=100,
            mode='determinate'
        )
        self.progress_bar.pack(fill=tk.X, pady=(0, 10))
        
        # Status labels
        self.status_var = tk.StringVar(value="Ready to transfer media files...")
        status_label = ttk.Label(progress_section, textvariable=self.status_var, font=("Helvetica", 10))
        status_label.pack(anchor="w", pady=(0, 5))
        
        self.stats_var = tk.StringVar()
        stats_label = ttk.Label(progress_section, textvariable=self.stats_var, font=("Helvetica", 9))
        stats_label.pack(anchor="w")
        
        # Log display
        log_frame = ttk.Frame(progress_section)
        log_frame.pack(fill=tk.BOTH, expand=True, pady=(10, 0))
        
        self.log_text = tk.Text(log_frame, height=8, wrap=tk.WORD, font=("Monaco", 9))
        log_scroll = ttk.Scrollbar(log_frame, orient=tk.VERTICAL, command=self.log_text.yview)
        self.log_text.configure(yscrollcommand=log_scroll.set)
        
        self.log_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        log_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Bottom info
        info_frame = ttk.Frame(main_frame)
        info_frame.pack(fill=tk.X, pady=(10, 0))
        
        version_label = ttk.Label(
            info_frame,
            text="GET SWIFTY Mobile Transfer v1.0.0",
            font=("Helvetica", 8),
            foreground="gray"
        )
        version_label.pack(side=tk.RIGHT)
    
    def select_folder(self):
        """Open folder selection dialog."""
        folder = filedialog.askdirectory(title="Select Destination Folder for Media Files")
        if folder:
            self.folder_var.set(folder)
            self.target_folder = Path(folder)
            self.log_message(f"üìÅ Destination folder set: {folder}")
    
    def start_device_monitoring(self):
        """Start monitoring for device connections."""
        def monitor_loop():
            while True:
                try:
                    devices = self.device_manager.scan_for_devices()
                    self.update_device_list(devices)
                    time.sleep(3)  # Check every 3 seconds
                except Exception as e:
                    self.log_message(f"‚ùå Device monitoring error: {e}")
                    time.sleep(5)
        
        monitor_thread = threading.Thread(target=monitor_loop, daemon=True)
        monitor_thread.start()
    
    def update_device_list(self, devices: Dict[str, List[str]]):
        """Update device list in GUI."""
        # Clear existing items
        for item in self.device_tree.get_children():
            self.device_tree.delete(item)
        
        # Add Android devices
        for device_id in devices['android']:
            capabilities = self.device_manager.device_capabilities.get(device_id, {})
            self.device_tree.insert('', tk.END, text=device_id, values=(
                'Android',
                capabilities.get('model', 'Unknown'),
                'Connected' if device_id in devices['android'] else 'Disconnected'
            ))
        
        # Add iOS devices
        for device_id in devices['ios']:
            capabilities = self.device_manager.device_capabilities.get(device_id, {})
            self.device_tree.insert('', tk.END, text=device_id, values=(
                'iOS',
                capabilities.get('model', 'Unknown'),
                'Connected' if device_id in devices['ios'] else 'Disconnected'
            ))
    
    def start_transfer(self):
        """Start media transfer from all connected devices."""
        if not self.target_folder:
            messagebox.showerror("Error", "Please select a destination folder first.")
            return
        
        selected_devices = []
        for item in self.device_tree.get_children():
            device_id = self.device_tree.item(item, 'text')
            device_type = self.device_tree.item(item, 'values')[0]
            if self.device_tree.item(item, 'values')[2] == 'Connected':
                selected_devices.append((device_id, device_type.lower()))
        
        if not selected_devices:
            messagebox.showwarning("Warning", "No connected devices found.")
            return
        
        self.transfer_active = True
        self.start_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)
        
        def transfer_thread():
            total_stats = {
                'total_files': 0,
                'successful_transfers': 0,
                'failed_transfers': 0,
                'total_size': 0
            }
            
            for device_id, device_type in selected_devices:
                if not self.transfer_active:
                    break
                
                self.log_message(f"üîÑ Starting transfer from {device_type} device: {device_id}")
                
                try:
                    if device_type == 'android':
                        handler = AndroidDeviceHandler(device_id, str(self.target_folder), self)
                        media_files = handler.discover_media_files()
                        if media_files:
                            stats = handler.batch_transfer(media_files)
                        else:
                            stats = handler.transfer_stats
                    
                    elif device_type == 'ios':
                        handler = IOSDeviceHandler(device_id, str(self.target_folder), self)
                        media_files = handler.discover_media_files()
                        if media_files:
                            stats = handler.batch_transfer(media_files)
                        else:
                            stats = handler.transfer_stats
                    
                    # Update total statistics
                    for key in total_stats:
                        total_stats[key] += stats.get(key, 0)
                    
                    self.log_message(
                        f"‚úÖ {device_type} {device_id}: {stats['successful_transfers']} files transferred"
                    )
                    
                except Exception as e:
                    self.log_message(f"‚ùå Transfer failed for {device_type} {device_id}: {e}")
            
            # Final statistics
            self.update_final_stats(total_stats)
            
            # Re-enable controls
            self.root.after(0, lambda: [
                setattr(self, 'transfer_active', False),
                self.start_button.config(state=tk.NORMAL),
                self.stop_button.config(state=tk.DISABLED)
            ])
        
        threading.Thread(target=transfer_thread, daemon=True).start()
    
    def stop_transfer(self):
        """Stop ongoing transfers."""
        self.transfer_active = False
        self.log_message("‚èπÔ∏è Transfer stopped by user")
        
        self.start_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.DISABLED)
    
    def organize_files(self):
        """Organize transferred files."""
        if not self.target_folder:
            messagebox.showerror("Error", "Please select a destination folder first.")
            return
        
        def organize_thread():
            organizer = MediaOrganizer(str(self.target_folder), self)
            
            # Find all media files in target folder
            media_files = []
            for file_type in MEDIA_EXTENSIONS.keys():
                type_folder = self.target_folder / file_type
                if type_folder.exists():
                    for file_path in type_folder.rglob('*'):
                        if file_path.is_file():
                            media_files.append(file_path)
            
            if media_files:
                self.log_message(f"üìÅ Organizing {len(media_files)} media files...")
                stats = organizer.organize_files(media_files)
                self.log_message(
                    f"‚úÖ Organization complete: {stats['files_organized']} files organized, "
                    f"{stats['duplicates_removed']} duplicates removed"
                )
            else:
                self.log_message("‚ÑπÔ∏è No media files found to organize")
        
        threading.Thread(target=organize_thread, daemon=True).start()
    
    def update_progress(self, current: int, total: int, message: str = None):
        """Update progress bar and status."""
        if total > 0:
            progress = (current / total) * 100
            self.progress_var.set(progress)
        
        if message:
            self.status_var.set(message)
    
    def update_final_stats(self, stats: Dict[str, Any]):
        """Update final transfer statistics."""
        size_mb = stats['total_size'] / (1024 * 1024)
        success_rate = (stats['successful_transfers'] / max(1, stats['total_files'])) * 100
        
        stats_text = (
            f"üìä Transfer Complete - Files: {stats['successful_transfers']}/{stats['total_files']} "
            f"({success_rate:.1f}%) | Size: {size_mb:.1f} MB | "
            f"Errors: {stats['failed_transfers']}"
        )
        self.stats_var.set(stats_text)
    
    def log_message(self, message: str):
        """Add message to log display."""
        timestamp = datetime.datetime.now().strftime('%H:%M:%S')
        formatted_message = f"[{timestamp}] {message}\n"
        
        self.log_text.insert(tk.END, formatted_message)
        self.log_text.see(tk.END)
        
        # Keep log size manageable
        lines = self.log_text.get(1.0, tk.END).count('\n')
        if lines > 100:
            self.log_text.delete(1.0, '10.0')
    
    def run(self):
        """Start the GUI application."""
        # Center window on screen
        self.root.update_idletasks()
        x = (self.root.winfo_screenwidth() // 2) - (self.root.winfo_width() // 2)
        y = (self.root.winfo_screenheight() // 2) - (self.root.winfo_height() // 2)
        self.root.geometry(f"+{x}+{y}")
        
        self.root.mainloop()


def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Mobile Media Transfer Station v1.0.0 - Professional mobile device media synchronization"
    )
    
    parser.add_argument(
        '--folder', '-f',
        help='Destination folder for media files'
    )
    
    parser.add_argument(
        '--no-gui',
        action='store_true',
        help='Run in command-line mode without GUI'
    )
    
    parser.add_argument(
        '--organize-only',
        action='store_true',
        help='Only organize existing files without transferring'
    )
    
    parser.add_argument(
        '--device-type',
        choices=['android', 'ios', 'both'],
        default='both',
        help='Specify device type to monitor'
    )
    
    parser.add_argument(
        '--version',
        action='version',
        version='Mobile Media Transfer Station v1.0.0 (GET SWIFTY)'
    )
    
    return parser.parse_args()


def main():
    """Main application entry point."""
    try:
        args = parse_arguments()
        
        if args.no_gui:
            # Command-line mode
            if not args.folder:
                print("‚ùå Error: Destination folder must be specified in command-line mode.")
                print("Usage: ./mobiles-media-transfer.py --folder /path/to/destination --no-gui")
                sys.exit(1)
            
            target_folder = Path(args.folder)
            target_folder.mkdir(parents=True, exist_ok=True)
            
            print(f"üì± Mobile Media Transfer Station v1.0.0")
            print(f"üìÅ Destination: {target_folder}")
            print(f"üîÑ Device monitoring started. Press Ctrl+C to stop.")
            
            device_manager = DeviceManager()
            requirements = device_manager.check_system_requirements()
            
            if not any(requirements.values()):
                print("‚ùå System requirements not met. Please install ADB and/or libimobiledevice.")
                sys.exit(1)
            
            print(f"‚úÖ System ready - ADB: {requirements['adb_available']}, "
                  f"iOS: {requirements['libimobiledevice_available']}")
            
            try:
                while True:
                    devices = device_manager.scan_for_devices()
                    
                    for device_id in devices['android']:
                        print(f"ü§ñ Processing Android device: {device_id}")
                        handler = AndroidDeviceHandler(device_id, str(target_folder))
                        media_files = handler.discover_media_files()
                        if media_files:
                            stats = handler.batch_transfer(media_files)
                            print(f"‚úÖ Transferred {stats['successful_transfers']} files")
                    
                    for device_id in devices['ios']:
                        print(f"üì± Processing iOS device: {device_id}")
                        handler = IOSDeviceHandler(device_id, str(target_folder))
                        media_files = handler.discover_media_files()
                        if media_files:
                            stats = handler.batch_transfer(media_files)
                            print(f"‚úÖ Transferred {stats['successful_transfers']} files")
                    
                    if args.organize_only:
                        organizer = MediaOrganizer(str(target_folder))
                        media_files = []
                        for file_path in target_folder.rglob('*'):
                            if file_path.is_file():
                                media_files.append(file_path)
                        if media_files:
                            organizer.organize_files(media_files)
                        break
                    
                    time.sleep(5)
                    
            except KeyboardInterrupt:
                print("\n‚èπÔ∏è Transfer stopped by user")
        
        else:
            # GUI mode
            app = MobileTransferGUI()
            if args.folder:
                app.folder_var.set(args.folder)
                app.target_folder = Path(args.folder)
            app.run()
    
    except Exception as e:
        print(f"‚ùå Application error: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()